static const char *RcsId = "$Id: AerotechAxis.cpp,v 1.4 2012/03/05 08:43:07 jean_coquet Exp $";
//+=============================================================================
//
// file :         AerotechAxis.cpp
//
// description :  C++ source for the AerotechAxis and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                AerotechAxis are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author: jean_coquet $
//
// $Revision: 1.4 $
//
// $Revision: 1.4 $
// $Date: 2012/03/05 08:43:07 $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source: /cvsroot/tango-ds/Motion/Aerotech/src/AerotechAxis.cpp,v $
// $Log: AerotechAxis.cpp,v $
// Revision 1.4  2012/03/05 08:43:07  jean_coquet
// bug correction on relativeMove attribute
// added AerotechAxis::SaveInFlash
// regenerated POGO Documentation for the 3 tango classes
//
// Revision 1.3  2012/03/02 16:26:26  jean_coquet
// technical commit
//
// Revision 1.2  2012/03/02 15:45:12  jean_coquet
// mise au point avec le materiel
//
// Revision 1.1  2012/02/23 17:46:18  olivierroux
// - initial import #21894
//
//
// copyleft :    Synchrotron SOLEIL 
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name                 |  Method name
//	----------------------------------------
//  State                        |  dev_state()
//  Status                       |  dev_status()
//  Stop                         |  stop()
//  InitializeReferencePosition  |  initialize_reference_position()
//  BrakeON                      |  brake_on()
//  BrakeOFF                     |  brake_off()
//  FaultAck                     |  fault_ack()
//  Enable                       |  enable()
//  Disable                      |  disable()
//  On                           |  on()
//  Off                          |  off()
//
//===================================================================


#include <tango.h>
#include <AerotechAxis.h>
#include <AerotechAxisClass.h>
#include <PogoHelper.h>
#include <yat4tango/ExceptionHelper.h>
#include <yat/Portability.h>
#include "lib/cEnsemble.h"
#include "lib/cA3200.h"


namespace AerotechAxis_ns
{

//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::AerotechAxis(string &s)
// 
// description : 	constructor for simulated AerotechAxis
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
AerotechAxis::AerotechAxis(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str())
{
	init_device();
}

AerotechAxis::AerotechAxis(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s)
{
	init_device();
}

AerotechAxis::AerotechAxis(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void AerotechAxis::delete_device()
{
	//	Delete device allocated objects
	DELETE_SCALAR_ATTRIBUTE(attr_position_read);
	DELETE_SCALAR_ATTRIBUTE(attr_offset_read);
	DELETE_SCALAR_ATTRIBUTE(attr_isBrakeOn_read);

	if (axis)
		delete axis;

}

//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void AerotechAxis::init_device()
{
	INFO_STREAM << "AerotechAxis::AerotechAxis() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	m_status_str = "initializing device...";
	m_properties_missing = false;
	m_init_device_done = false;
	axis_name = 0;
	axis = 0;

	CREATE_SCALAR_ATTRIBUTE(attr_position_read);
	CREATE_SCALAR_ATTRIBUTE(attr_offset_read);
	CREATE_SCALAR_ATTRIBUTE(attr_isBrakeOn_read);

	get_device_property();
	if (m_properties_missing) //- Status is updated in get_device_property()
		return;

	try
	{
		if (controllerType == "A3200")
		{
			axis = new Aerotech_ns::cA3200 (const_cast <char *> (axisId.c_str ()));
		}
		else if (controllerType == "ENSEMBLE")
		{
			axis = new Aerotech_ns::cEnsemble (const_cast <char *> (axisId.c_str ()));
		}
		else
		{
			ERROR_STREAM << "AerotechAxis: Initialization failed [unknown Controller type: " << controllerType << " ]" << std::endl;
			m_status_str = "Device initialization failed " + controllerType + " controller type not supported";
			return;
		}

		//- Some default parameters
		axis->set_wait_mode("NOWAIT"); // tested on ensemble only
	}
	catch (yat::Exception & ye)
	{
		ERROR_STREAM << "AerotechAxis: Initialization failed - YAT Error: " << std::string(ye.errors[0].desc) << std::endl;
		m_status_str = "Device initialization failed - YAT Error: \n" 
						+ std::string(ye.errors[0].desc);
		return;
	}
	catch (Tango::DevFailed &e)
	{
		ERROR_STREAM << "AerotechAxis: Initialization failed - Tango Error: " << e << std::endl;
		m_status_str = "Device initialization failed - Tango Error: \n"
						+ std::string(e.errors[0].desc);
		return;
	}
	catch (...)
	{
		ERROR_STREAM << "AerotechAxis: Initialization failed - Unknown Error" << std::endl;
		m_status_str = "Device initialization failed - Unknown Error";
		return;
	}

	m_init_device_done = true;

	dev_state();
}


//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void AerotechAxis::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------
	axisId = "must be defined [set the Axis names as defined in the controller for this Axis]";
	controllerType = "must be defined [set ControllerType to [A3200|ENSEMBLE]]";

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("AxisId"));
	dev_prop.push_back(Tango::DbDatum("ControllerType"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	AerotechAxisClass	*ds_class =
		(static_cast<AerotechAxisClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize AxisId from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  axisId;
	else {
		//	Try to initialize AxisId from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  axisId;
	}
	//	And try to extract AxisId value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  axisId;

	//	Try to initialize ControllerType from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  controllerType;
	else {
		//	Try to initialize ControllerType from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  controllerType;
	}
	//	And try to extract ControllerType value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  controllerType;



	//	End of Automatic code generation
	//------------------------------------------------------------------
	Tango::DbData data_put;
	if (dev_prop[0].is_empty()==true || axisId.find ("must be defined") != std::string::npos)
	{
		m_properties_missing = true;
		ERROR_STREAM << "AerotechAxis::get_device_property AxisId not defined [fix and restart device]" << std::endl;
		m_status_str = "AxisId is not defined [fix and restart device]";
		Tango::DbDatum	property("AxisId");
		property	<<	axisId;
		data_put.push_back(property);
	}
	if ((dev_prop[1].is_empty()==true) || 
		(controllerType.find ("A3200") == std::string::npos) &&
		(controllerType.find ("ENSEMBLE") == std::string::npos))
	{
		m_properties_missing = true;
		ERROR_STREAM << "AerotechBox::get_device_property ControllerType not defined" << std::endl;
		m_status_str = "ControllerType is not defined \n[set ControllerType to [A3200|ENSEMBLE] and restart device]";
		Tango::DbDatum	property("ControllerType");
		property	<<	controllerType;
		data_put.push_back(property);
	}
	if(!data_put.empty())
		get_db_device()->put_property(data_put);
}

//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void AerotechAxis::always_executed_hook()
{

}
//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void AerotechAxis::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "AerotechAxis::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::read_relativeMove
// 
// description : 	Extract real attribute values for relativeMove acquisition result.
//
//-----------------------------------------------------------------------------
void AerotechAxis::read_relativeMove(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AerotechAxis::read_relativeMove(Tango::Attribute &attr) entering... "<< endl;
	//- WRITE ONLY attribute
	if (! is_init() )
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::read_relativeMove");
}

//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::write_relativeMove
// 
// description : 	Write relativeMove attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AerotechAxis::write_relativeMove(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AerotechAxis::write_relativeMove(Tango::WAttribute &attr) entering... "<< endl;
	if (! is_init() )
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::write_relativeMove");

	//- already moving?
	if (axis->axis_is_moving()         ||
		axis->axis_is_accel_or_decel() ||
		axis->axis_is_homing())
	{
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"axis is already moving [wait for movement end]",
						"AerotechAxis::write_relativeMove");
	}
	int err;
	axis->get_axis_fault_status(err);
	if (err != 0)
	{
		char err_text [512];
		axis->error_to_string(err, err_text);
		THROW_DEVFAILED("OPERATION_NOT_ALLOWED",
						err_text,
						"AerotechAxis::write_relativeMove");
	}
	attr.get_write_value(attr_relativeMove_write);
	axis->axis_move_rel( attr_relativeMove_write);

}

//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::read_isBrakeOn
// 
// description : 	Extract real attribute values for isBrakeOn acquisition result.
//
//-----------------------------------------------------------------------------
void AerotechAxis::read_isBrakeOn(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AerotechAxis::read_isBrakeOn(Tango::Attribute &attr) entering... "<< endl;
	if (! is_init ())
		return;
	*attr_isBrakeOn_read = axis->axis_is_brake_on ();
	attr.set_value (attr_isBrakeOn_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::read_position
// 
// description : 	Extract real attribute values for position acquisition result.
//
//-----------------------------------------------------------------------------
void AerotechAxis::read_position(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AerotechAxis::read_position(Tango::Attribute &attr) entering... "<< endl;
	if (! is_init ())
		return;

	//if (axis->get_axis_position_user (*attr_position_read))
	axis->get_axis_position_user (*attr_position_read);
	attr.set_value (attr_position_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::write_position
// 
// description : 	Write position attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AerotechAxis::write_position(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AerotechAxis::write_position(Tango::WAttribute &attr) entering... "<< endl;
	if (! is_init ())
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::write_position");

	//- already moving?
	if (axis->axis_is_moving ()         ||
		axis->axis_is_accel_or_decel () ||
		axis->axis_is_homing ())
	{
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"axis is already moving [wait for movement end]",
						"AerotechAxis::write_position");
	}
	int err;
	axis->get_axis_fault_status (err);
	if (err != 0)
	{
		char err_text [256];
		axis->error_to_string (err, err_text);
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						err_text,
						"AerotechAxis::write_position");
	}

	attr.get_write_value(attr_position_write);
	axis->axis_move_abs_user(attr_position_write);

}

//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::read_offset
// 
// description : 	Extract real attribute values for offset acquisition result.
//
//-----------------------------------------------------------------------------
void AerotechAxis::read_offset(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AerotechAxis::read_offset(Tango::Attribute &attr) entering... "<< endl;
	if (! is_init ())
		return;

	*attr_offset_read = axis->get_offset ();
	attr.set_value (attr_offset_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::write_offset
// 
// description : 	Write offset attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AerotechAxis::write_offset(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AerotechAxis::write_offset(Tango::WAttribute &attr) entering... "<< endl;
	if (! is_init ())
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::write_offset");
	attr.get_write_value (attr_offset_write);
	axis->set_offset (attr_offset_write);
}

//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::read_velocity
// 
// description : 	Extract real attribute values for velocity acquisition result.
//
//-----------------------------------------------------------------------------
void AerotechAxis::read_velocity(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AerotechAxis::read_velocity(Tango::Attribute &attr) entering... "<< endl;

    //- WRITE ONLY attr

}

//+----------------------------------------------------------------------------
//
// method : 		AerotechAxis::write_velocity
// 
// description : 	Write velocity attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AerotechAxis::write_velocity(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AerotechAxis::write_velocity(Tango::WAttribute &attr) entering... "<< endl;
	if (! is_init ())
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::write_velocity");

	int err = 0;
	axis->get_axis_fault_status (err);
	if (err != 0)
	{
		char err_text [256];
		axis->error_to_string(err, err_text);
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						err_text,
						"AerotechAxis::write_velocity");
	}
	attr.get_write_value(attr_velocity_write);
	if (!axis->set_axis_velocity(attr_velocity_write))
		THROW_DEVFAILED ("COMMAND_FAILED",
						"command failed [controller refused command]",
						"AerotechAxis::write_velocity");

}

//+------------------------------------------------------------------
/**
 *	method:	AerotechAxis::stop
 *
 *	description:	method to execute "Stop"
 *	Stops motor
 *
 *
 */
//+------------------------------------------------------------------
void AerotechAxis::stop()
{
	DEBUG_STREAM << "AerotechAxis::stop(): entering... !" << endl;

	//	Add your own code to control device here
	if (! is_init ())
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::stop");
	if (!axis->axis_abort ())
		THROW_DEVFAILED ("COMMAND_FAILED",
						"command failed [controller refused command]",
						"AerotechAxis::stop");
}

//+------------------------------------------------------------------
/**
 *	method:	AerotechAxis::initialize_reference_position
 *
 *	description:	method to execute "InitializeReferencePosition"
 *	makes a Home 0
 *
 *
 */
//+------------------------------------------------------------------
void AerotechAxis::initialize_reference_position()
{
	DEBUG_STREAM << "AerotechAxis::initialize_reference_position(): entering... !" << endl;

	//	Add your own code to control device here
	if (! is_init ())
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::initialize_reference_position");
	if (!axis->axis_home ())
		THROW_DEVFAILED ("COMMAND_FAILED",
						"command failed [controller refused command]",
						"AerotechAxis::initialize_reference_position");
}

//+------------------------------------------------------------------
/**
 *	method:	AerotechAxis::brake_on
 *
 *	description:	method to execute "BrakeON"
 *	applies the brake
 *
 *
 */
//+------------------------------------------------------------------
void AerotechAxis::brake_on()
{
	DEBUG_STREAM << "AerotechAxis::brake_on(): entering... !" << endl;

	//	Add your own code to control device here
	if (! is_init ())
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::brake_on");

	if (!axis->axis_brake_on ())
		THROW_DEVFAILED ("COMMAND_FAILED",
						"command failed [controller refused command]",
						"AerotechAxis::brake_on");

}

//+------------------------------------------------------------------
/**
 *	method:	AerotechAxis::brake_off
 *
 *	description:	method to execute "BrakeOFF"
 *	release the brake
 *
 *
 */
//+------------------------------------------------------------------
void AerotechAxis::brake_off()
{
	DEBUG_STREAM << "AerotechAxis::brake_off(): entering... !" << endl;

	//	Add your own code to control device here
	if (! is_init ())
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::brake_off");

	if (!axis->axis_brake_off ())
		THROW_DEVFAILED ("COMMAND_FAILED",
						"command failed [controller refused command]",
						"AerotechAxis::brake_off");
}


//+------------------------------------------------------------------
/**
 *	method:	AerotechAxis::fault_ack
 *
 *	description:	method to execute "FaultAck"
 *	Acknowledges and clears faults on the Ensemble Driver
 *
 *
 */
//+------------------------------------------------------------------
void AerotechAxis::fault_ack()
{
	DEBUG_STREAM << "AerotechAxis::fault_ack(): entering... !" << endl;

	//	Add your own code to control device here
	if (! is_init ())
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::fault_ack");

	if (!axis->axis_fault_ack ())
		THROW_DEVFAILED ("COMMAND_FAILED",
						"command failed [controller refused command]",
						"AerotechAxis::fault_ack");
}

//+------------------------------------------------------------------
/**
*	method:	AerotechAxis::dev_state
*
*	description:	method to execute "State"
*	This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
*
* @return	State Code
*
*/
//+------------------------------------------------------------------
Tango::DevState AerotechAxis::dev_state()
{
	Tango::DevState	argout = Tango::UNKNOWN;
	DEBUG_STREAM << "AerotechAxis::dev_state(): entering... !" << endl;

	//	Add your own code to control device here
	//- Init failed
	if (!m_init_device_done || m_properties_missing)
	{
		argout = Tango::FAULT;
		set_state (argout);
		return argout;
	}

	//- Connection with controller failed
	if (!axis->connected_ok ())
	{
		argout = Tango::FAULT;
		set_state (argout);
		return argout;
	}

	int err = 0;
	axis->get_axis_fault_status ( err);

	//- could not move (driver disabled = OFF)
	if (!axis->axis_is_enabled ())
	{
		argout = Tango::OFF;
		set_state (argout);
		return argout;
	}

	//- could not move (brake ON : axis stopped)
	if (axis->axis_is_brake_on ())
	{
		argout = Tango::STANDBY;
		set_state (argout);
		return argout;
	}

	//- moving
	if (axis->axis_is_moving ()         ||
		axis->axis_is_accel_or_decel () ||
		axis->axis_is_homing ())
	{
		argout = Tango::MOVING;
		set_state (argout);
		return argout;
	}

	//- Alarm
	if (!axis->axis_is_homed () ||
		((err & 0x3C) != 0))            //- Hard or soft limits
	{
		argout = Tango::ALARM;
		set_state (argout);
		return argout;
	}

	//- fault
	if (axis->axis_is_emergency_stop () ||
		err != 0)
	{
		argout = Tango::FAULT;
		set_state (argout);
		return argout;
	} 

	//- Standby
	if (axis->axis_is_in_position ())
	{
		argout = Tango::STANDBY;
		set_state (argout);
		return argout;
	}

	//- out of position, not moving,... dont know.
	argout = Tango::ALARM;
	set_state(argout);
	return argout;
}

//+------------------------------------------------------------------
/**
*	method:	AerotechAxis::dev_status
*
*	description:	method to execute "Status"
*	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
*
* @return	Status description
*
*/
//+------------------------------------------------------------------
Tango::ConstDevString AerotechAxis::dev_status()
{
	DEBUG_STREAM << "AerotechAxis::dev_status(): entering... !" << endl;

	//	Add your own code to control device here
	if (!m_init_device_done || m_properties_missing)
	{
		set_status (m_status_str.c_str ());
		return m_status_str.c_str ();
	}
	m_status_str.clear ();

	if (!axis->connected_ok ())
	{
		m_status_str += "communication not working\n";
		return m_status_str.c_str ();
	}

	if (axis->axis_is_enabled ())
		m_status_str += "Axis On (Enabled)\n";
	else
		m_status_str += "Axis Off (Disabled)\n";
	if (axis->axis_is_emergency_stop ())
		m_status_str += "Emergency Stop\n";
	if (axis->axis_is_brake_on ())
		m_status_str += "Brake ON\n";
	if (axis->axis_is_brake_off ())
		m_status_str += "Brake OFF\n";
	if (axis->axis_is_homed ())
		m_status_str += "Axis Homing Done\n";
	else
		m_status_str += "Axis NOT HOMED\n";
	if (axis->axis_is_moving ())
		m_status_str += "Axis Moving\n";
	if (axis->axis_is_accelerating ())
		m_status_str += "Axis Accelerating\n";
	if (axis->axis_is_decelerating ())
		m_status_str += "Axis Decelerating\n";
	if (axis->axis_is_accel_or_decel ())
		m_status_str += "Axis Accelerating OR decelerating\n";
	if (axis->axis_is_in_position ())
		m_status_str += "Axis in position\n";
	else
		m_status_str += "Axis NOT in position\n";

	//- errors if any
	int err;


	if (axis->get_axis_fault_status (err))
	{
		DEBUG_STREAM << "AerotechAxis::dev_status() get_axis_fault_status returned <" << err << ">" << std::endl;
		char errors [512];
		axis->error_to_string(err, errors);
		m_status_str += errors;
	}

	return m_status_str.c_str ();


}

//+------------------------------------------------------------------
/**
*	internal method:	AerotechAxis::is_init
*
* @return	boo true is init of device is ok 
*
*/
//+------------------------------------------------------------------
bool AerotechAxis::is_init()
{
	DEBUG_STREAM << "AerotechAxis::is_init(): entering... !" << endl;

	//	Add your own code to control device here
	if (!m_init_device_done || m_properties_missing)
		return false;
	if (!axis->connected_ok ())
		return false;
	return true;
}


//+------------------------------------------------------------------
/**
 *	method:	AerotechAxis::enable
 *
 *	description:	method to execute "Enable"
 *	enables the related driver
 *
 *
 */
//+------------------------------------------------------------------
void AerotechAxis::enable()
{
	DEBUG_STREAM << "AerotechAxis::enable(): entering... !" << endl;

	//	Add your own code to control device here
	if (! is_init ())
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::enable");

	if (!axis->axis_enable ())
		THROW_DEVFAILED ("COMMAND_FAILED",
						"command failed [controller refused command]",
						"AerotechAxis::enable");
}

//+------------------------------------------------------------------
/**
 *	method:	AerotechAxis::disable
 *
 *	description:	method to execute "Disable"
 *	disables the related driver
 *
 *
 */
//+------------------------------------------------------------------
void AerotechAxis::disable()
{
	DEBUG_STREAM << "AerotechAxis::disable(): entering... !" << endl;

	//	Add your own code to control device here
	if (! is_init ())
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::disable");

	if (!axis->axis_disable ())
		THROW_DEVFAILED ("COMMAND_FAILED",
						"command failed [controller refused command]",
						"AerotechAxis::disable");
}

//+------------------------------------------------------------------
/**
 *	method:	AerotechAxis::on
 *
 *	description:	method to execute "On"
 *	Enable power driver
 *	same as Enable cmd
 *
 *
 */
//+------------------------------------------------------------------
void AerotechAxis::on()
{
	DEBUG_STREAM << "AerotechAxis::on(): entering... !" << endl;

	//	Add your own code to control device here
	if (! is_init ())
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::on");

	if (!axis->axis_enable ())
		THROW_DEVFAILED ("COMMAND_FAILED",
						"command failed [controller refused command]",
						"AerotechAxis::on");

}

//+------------------------------------------------------------------
/**
 *	method:	AerotechAxis::off
 *
 *	description:	method to execute "Off"
 *	Disable power driver
 *	same as Disable cmd
 *
 *
 */
//+------------------------------------------------------------------
void AerotechAxis::off()
{
	DEBUG_STREAM << "AerotechAxis::off(): entering... !" << endl;

	//	Add your own code to control device here
	if (! is_init ())
		THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
						"device not properly initialized [check properties, communication lost]",
						"AerotechAxis::off");

	if (!axis->axis_disable ())
		THROW_DEVFAILED ("COMMAND_FAILED",
						"command failed [controller refused command]",
						"AerotechAxis::off");

}


}	//	namespace
