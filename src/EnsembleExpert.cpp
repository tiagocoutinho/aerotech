static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         EnsembleExpert.cpp
//
// description :  C++ source for the EnsembleExpert and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                EnsembleExpert are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL 
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name|  Method name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//  Reset   |  reset()
//
//===================================================================


#include <tango.h>
#include <EnsembleExpert.h>
#include <EnsembleExpertClass.h>
#include <helpers/PogoHelper.h>
#include <yat4tango/ExceptionHelper.h>
#include "cEnsemble.h"

namespace EnsembleExpert_ns
{

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::EnsembleExpert(string &s)
// 
// description : 	constructor for simulated EnsembleExpert
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
EnsembleExpert::EnsembleExpert(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str())
{
	init_device();
}

EnsembleExpert::EnsembleExpert(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s)
{
	init_device();
}

EnsembleExpert::EnsembleExpert(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::delete_device()
{
	//	Delete device allocated objects
  DELETE_SCALAR_ATTRIBUTE(attr_positionError_read);
  DELETE_SCALAR_ATTRIBUTE(attr_currentVelocity_read);
  DELETE_SCALAR_ATTRIBUTE(attr_lowLimit_read);
  DELETE_SCALAR_ATTRIBUTE(attr_highLimit_read);
  DELETE_SCALAR_ATTRIBUTE(attr_rampRate_read);
  DELETE_SCALAR_ATTRIBUTE(attr_homeVelocity_read);
  DELETE_SCALAR_ATTRIBUTE(attr_homeOffset_read);
  DELETE_SCALAR_ATTRIBUTE(attr_statusRaw_read);
  DELETE_SCALAR_ATTRIBUTE(attr_errorRaw_read);

}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::init_device()
{
	INFO_STREAM << "EnsembleExpert::EnsembleExpert() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
  m_properties_missing = false;
  m_init_device_done = false;

  
  CREATE_SCALAR_ATTRIBUTE(attr_positionError_read);
  CREATE_SCALAR_ATTRIBUTE(attr_currentVelocity_read);
  CREATE_SCALAR_ATTRIBUTE(attr_lowLimit_read);
  CREATE_SCALAR_ATTRIBUTE(attr_highLimit_read);
  CREATE_SCALAR_ATTRIBUTE(attr_rampRate_read);
  CREATE_SCALAR_ATTRIBUTE(attr_homeVelocity_read);
  CREATE_SCALAR_ATTRIBUTE(attr_homeOffset_read);
  CREATE_SCALAR_ATTRIBUTE(attr_statusRaw_read);
  CREATE_SCALAR_ATTRIBUTE(attr_errorRaw_read);

  get_device_property();
  if (m_properties_missing)
    return;

  this->axis_name = const_cast <char*> (axisId.c_str ());

  bool connected = ENSEMBLE_PROXY->connected_ok ();
  if (!connected)
  {
    ERROR_STREAM << "EnsembleAxis::init_device could not connect to Ensemble controller [check connections , try to restart DS]" << std::endl;
    m_status_str = "could not connect to Ensemble controller [check connections , try to restart DS]\n";
    return;
  }

	this->m_init_device_done = true;
}


//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------
  axisId = "X";

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("AxisId"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	EnsembleExpertClass	*ds_class =
		(static_cast<EnsembleExpertClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize AxisId from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  axisId;
	else {
		//	Try to initialize AxisId from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  axisId;
	}
	//	And try to extract AxisId value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  axisId;



	//	End of Automatic code generation
	//------------------------------------------------------------------
  Tango::DbData data_put;
  if (dev_prop[0].is_empty()==true)
	{
    INFO_STREAM << "EnsembleBox::get_device_property AxisId not defined [set to default value <X>]" << std::endl;
    this->m_status_str = "EnsembleBox::get_device_property AxisId not defined [set to default value <X>]";
		Tango::DbDatum	property("AxisId");
		property	<<	axisId;
		data_put.push_back(property);
	}
	if(!data_put.empty())
		get_db_device()->put_property(data_put);
}
//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void EnsembleExpert::always_executed_hook()
{
	
}
//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "EnsembleExpert::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::read_rampRate
// 
// description : 	Extract real attribute values for rampRate acquisition result.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::read_rampRate(Tango::Attribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::read_rampRate(Tango::Attribute &attr) entering... "<< endl;
  if (! is_init ())
    return;
  ENSEMBLE_PROXY->get_axis_ramp_rate (this->axis_name, *attr_rampRate_read);
  attr.set_value (attr_rampRate_read);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::write_rampRate
// 
// description : 	Write rampRate attribute values to hardware.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::write_rampRate(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::write_rampRate(Tango::WAttribute &attr) entering... "<< endl;
  if (! is_init ())
    THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
                     "device not properly initialized [check properties, communication lost]",
                     "EnsembleAxis::write_rampRate");


  attr.get_write_value (attr_rampRate_write);
  ENSEMBLE_PROXY->axis_move_abs (this->axis_name, attr_rampRate_write);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::read_positionError
// 
// description : 	Extract real attribute values for positionError acquisition result.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::read_positionError(Tango::Attribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::read_positionError(Tango::Attribute &attr) entering... "<< endl;
  if (! is_init ())
    return;
  ENSEMBLE_PROXY->get_axis_position (this->axis_name, *attr_positionError_read);
  attr.set_value (attr_positionError_read);

}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::read_currentVelocity
// 
// description : 	Extract real attribute values for currentVelocity acquisition result.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::read_currentVelocity(Tango::Attribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::read_currentVelocity(Tango::Attribute &attr) entering... "<< endl;
  if (! is_init ())
    return;
  ENSEMBLE_PROXY->get_axis_velocity (this->axis_name, *attr_currentVelocity_read);
  attr.set_value (attr_currentVelocity_read);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::write_currentVelocity
// 
// description : 	Write currentVelocity attribute values to hardware.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::write_currentVelocity(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::write_currentVelocity(Tango::WAttribute &attr) entering... "<< endl;
  if (! is_init ())
    THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
                     "device not properly initialized [check properties, communication lost]",
                     "EnsembleAxis::write_currentVelocity");


  attr.get_write_value (attr_currentVelocity_write);
  ENSEMBLE_PROXY->axis_move_abs (this->axis_name, attr_currentVelocity_write);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::read_lowLimit
// 
// description : 	Extract real attribute values for lowLimit acquisition result.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::read_lowLimit(Tango::Attribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::read_lowLimit(Tango::Attribute &attr) entering... "<< endl;
  if (! is_init ())
    return;
  ENSEMBLE_PROXY->get_axis_software_limit_low (this->axis_name, *attr_lowLimit_read);
  attr.set_value (attr_lowLimit_read);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::write_lowLimit
// 
// description : 	Write lowLimit attribute values to hardware.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::write_lowLimit(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::write_lowLimit(Tango::WAttribute &attr) entering... "<< endl;
  if (! is_init ())
    THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
                     "device not properly initialized [check properties, communication lost]",
                     "EnsembleAxis::write_lowLimit");


  attr.get_write_value (attr_lowLimit_write);
  ENSEMBLE_PROXY->set_axis_software_limit_low (this->axis_name, attr_lowLimit_write);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::read_highLimit
// 
// description : 	Extract real attribute values for highLimit acquisition result.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::read_highLimit(Tango::Attribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::read_highLimit(Tango::Attribute &attr) entering... "<< endl;
  if (! is_init ())
    return;
  ENSEMBLE_PROXY->get_axis_software_limit_high (this->axis_name, *attr_highLimit_read);
  attr.set_value (attr_highLimit_read);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::write_highLimit
// 
// description : 	Write highLimit attribute values to hardware.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::write_highLimit(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::write_highLimit(Tango::WAttribute &attr) entering... "<< endl;
  if (! is_init ())
    THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
                     "device not properly initialized [check properties, communication lost]",
                     "EnsembleAxis::write_lowLimit");


  attr.get_write_value (attr_highLimit_write);
  ENSEMBLE_PROXY->set_axis_software_limit_high (this->axis_name, attr_highLimit_write);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::read_homeVelocity
// 
// description : 	Extract real attribute values for homeVelocity acquisition result.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::read_homeVelocity(Tango::Attribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::read_homeVelocity(Tango::Attribute &attr) entering... "<< endl;
  if (! is_init ())
    return;
  ENSEMBLE_PROXY->get_axis_home_speed (this->axis_name, *attr_homeVelocity_read);
  attr.set_value (attr_homeVelocity_read);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::write_homeVelocity
// 
// description : 	Write homeVelocity attribute values to hardware.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::write_homeVelocity(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::write_homeVelocity(Tango::WAttribute &attr) entering... "<< endl;
  if (! is_init ())
    THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
                     "device not properly initialized [check properties, communication lost]",
                     "EnsembleAxis::write_homeVelocity");


  attr.get_write_value (attr_homeVelocity_write);
  ENSEMBLE_PROXY->set_axis_home_speed (this->axis_name, attr_homeVelocity_write);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::read_homeOffset
// 
// description : 	Extract real attribute values for homeOffset acquisition result.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::read_homeOffset(Tango::Attribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::read_homeOffset(Tango::Attribute &attr) entering... "<< endl;
  if (! is_init ())
    return;
  ENSEMBLE_PROXY->get_axis_home_offset (this->axis_name, *attr_homeOffset_read);
  attr.set_value (attr_homeOffset_read);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::write_homeOffset
// 
// description : 	Write homeOffset attribute values to hardware.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::write_homeOffset(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::write_homeOffset(Tango::WAttribute &attr) entering... "<< endl;
  if (! is_init ())
    THROW_DEVFAILED ("OPERATION_NOT_ALLOWED",
                     "device not properly initialized [check properties, communication lost]",
                     "EnsembleAxis::write_homeOffset");


  attr.get_write_value (attr_homeOffset_write);
  ENSEMBLE_PROXY->set_axis_home_offset (this->axis_name, attr_homeOffset_write);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::read_statusRaw
// 
// description : 	Extract real attribute values for statusRaw acquisition result.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::read_statusRaw(Tango::Attribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::read_statusRaw(Tango::Attribute &attr) entering... "<< endl;
  if (! is_init ())
    return;
  int i = 0;
  ENSEMBLE_PROXY->get_axis_status (this->axis_name, i);
  *attr_statusRaw_read = static_cast <long> (i);
  attr.set_value (attr_statusRaw_read);
}

//+----------------------------------------------------------------------------
//
// method : 		EnsembleExpert::read_errorRaw
// 
// description : 	Extract real attribute values for errorRaw acquisition result.
//
//-----------------------------------------------------------------------------
void EnsembleExpert::read_errorRaw(Tango::Attribute &attr)
{
	DEBUG_STREAM << "EnsembleExpert::read_errorRaw(Tango::Attribute &attr) entering... "<< endl;
  if (! is_init ())
    return;
  int i = 0;
  ENSEMBLE_PROXY->get_axis_fault_status (this->axis_name, i);
 *attr_errorRaw_read =  static_cast <long> (i);
  attr.set_value (attr_errorRaw_read);
}

//+------------------------------------------------------------------
/**
 *	method:	EnsembleExpert::reset
 *
 *	description:	method to execute "Reset"
 *	resets the controller.
 *	Communication is lost : you must wait for the controller to have finished its reboot 
 *	and issue a Init Cmd on the EnsembleBox device to restart communication
 *
 *
 */
//+------------------------------------------------------------------
void EnsembleExpert::reset()
{
	DEBUG_STREAM << "EnsembleExpert::reset(): entering... !" << endl;

	//	Add your own code to control device here
  bool ok = false;
  ok = ENSEMBLE_PROXY->reset ();
  if (!ok)
   THROW_DEVFAILED ("COMMAND_FAILED",
                    "command failed [controller refused command]",
                    "EnsembleAxis::reset");

}


//+------------------------------------------------------------------
/**
 *	method:	EnsembleExpert::dev_state
 *
 *	description:	method to execute "State"
 *	This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return	State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState EnsembleExpert::dev_state()
{
	Tango::DevState	argout = DeviceImpl::dev_state();
	DEBUG_STREAM << "EnsembleExpert::dev_state(): entering... !" << endl;

	//	Add your own code to control device here
  if (!m_init_device_done || m_properties_missing)
  {
    argout = Tango::FAULT;
    set_state (argout);
    return argout;
  }
  if (!ENSEMBLE_PROXY->connected_ok ())
  {
    argout = Tango::FAULT;
    set_state (argout);
    return argout;
  }

  int st = 0;
  ENSEMBLE_PROXY->get_axis_status (this->axis_name, st);

  //- could not move (brake ON or driver disabled)
  if (ENSEMBLE_PROXY->is_brake_on (st) ||
      !ENSEMBLE_PROXY->is_enabled (st))
  {
    argout = Tango::DISABLE;
    set_state (argout);
    return argout;
  }

  //- moving
  if (ENSEMBLE_PROXY->is_moving (st)         ||
      ENSEMBLE_PROXY->is_accel_or_decel (st) ||
      ENSEMBLE_PROXY->is_homing (st))
  {
    argout = Tango::MOVING;
    set_state (argout);
    return argout;
  }

  //- Alarm
  if (!ENSEMBLE_PROXY->is_homed (st))
  {
    argout = Tango::ALARM;
    set_state (argout);
    return argout;
  }

  //- Standby
  if (!ENSEMBLE_PROXY->is_in_position (st))
  {
    argout = Tango::STANDBY;
    set_state (argout);
    return argout;
  }

  //- fault
  int err = 0;
  ENSEMBLE_PROXY->get_axis_fault_status (this->axis_name, err);
  if (ENSEMBLE_PROXY->is_emergency_stop (st) ||
      ENSEMBLE_PROXY->is_encoder_error  (st) ||
      err != 0)
  {
    argout = Tango::FAULT;
    set_state (argout);
    return argout;
  }
  
  //- out of position, not moving,... dont know.
  argout = Tango::ALARM;
	set_state(argout);
	return argout;}

//+------------------------------------------------------------------
/**
 *	method:	EnsembleExpert::dev_status
 *
 *	description:	method to execute "Status"
 *	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 * @return	Status description
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString EnsembleExpert::dev_status()
{
	DEBUG_STREAM << "EnsembleExpert::dev_status(): entering... !" << endl;

	//	Add your own code to control device here
  if (!m_init_device_done || m_properties_missing)
  {
    set_status (m_status_str.c_str ());
    return m_status_str.c_str ();
  }
  m_status_str.clear ();

  if (!ENSEMBLE_PROXY->connected_ok ())
  {
    m_status_str += "communication not working\n";
    return m_status_str.c_str ();
  }

  int st = 0;
  ENSEMBLE_PROXY->get_axis_status (this->axis_name, st);
  if (ENSEMBLE_PROXY->is_enabled (st))
    m_status_str += "Axis Enabled\n";
  else
    m_status_str += "Axis Disabled\n";
  if (ENSEMBLE_PROXY->is_encoder_error (st))
    m_status_str += "Encoder Error\n";
  if (ENSEMBLE_PROXY->is_encoder_error (st))
    m_status_str += "Encoder Error\n";
  if (ENSEMBLE_PROXY->is_emergency_stop (st))
    m_status_str += "Emergency Stop\n";
  if (ENSEMBLE_PROXY->is_brake_on (st))
    m_status_str += "Brake ON\n";
  if (ENSEMBLE_PROXY->is_brake_off (st))
    m_status_str += "Brake OFF\n";
  if (ENSEMBLE_PROXY->is_homed (st))
    m_status_str += "Axis Homing Done\n";
  if (ENSEMBLE_PROXY->is_moving (st))
    m_status_str += "Axis Moving\n";
  if (ENSEMBLE_PROXY->is_accelerating (st))
    m_status_str += "Axis Accelerating\n";
  if (ENSEMBLE_PROXY->is_decelerating (st))
    m_status_str += "Axis Decelerating\n";
  if (ENSEMBLE_PROXY->is_in_position (st))
    m_status_str += "Axis in position\n";
  else
    m_status_str += "Axis NOT in position\n";

  //- errors if any
  int err;
  if (ENSEMBLE_PROXY->get_axis_fault_status (axis_name, err))
  {
    char errors [512];
    ENSEMBLE_PROXY->error_to_string(err, errors);
    m_status_str += errors;
  }

  return m_status_str.c_str ();

}


//+------------------------------------------------------------------
/**
 *	internal method:	EnsembleExpert::is_init
 *
 * @return	boo true is init of device is ok 
 *
 */
//+------------------------------------------------------------------
bool EnsembleExpert::is_init()
{
	DEBUG_STREAM << "EnsembleExpert::is_init(): entering... !" << endl;

	//	Add your own code to control device here
  if (!m_init_device_done || m_properties_missing)
    return false;
  if (! ENSEMBLE_PROXY->connected_ok ())
    return false;

  return true;
}



}	//	namespace
